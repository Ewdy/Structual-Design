{"backend_state":"running","kernel":"python3","kernel_state":"idle","kernel_usage":{"cpu":0,"memory":116092928},"metadata":{"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.6.8"}},"trust":true,"type":"settings"}
{"cell_type":"code","end":1564141797751,"exec_count":1,"id":"e90db1","input":"import numpy as np\n\n# Pint Unit Library\nfrom pint import UnitRegistry\nunit = UnitRegistry()\nQ_ = unit.Quantity\nunit.default_format = '~' # ~ for unit abreviations, P for prettyprint, or both\n# Define symbols for common units\n# Length\nm = unit.meter; mm = unit.millimeter; inch = unit.inch; foot = unit.foot;\n# Force\nN = unit.newton; kN = unit.kilonewton; lbf = unit.pound_force; kip = unit.kip\n# Pressure\nkPa = unit.kilopascal; MPa = unit.megapascal; psi = unit.psi; ksi = unit.ksi;\n# Mass\nkg = unit.kilogram; lbs = unit.pound;\n# Acceleration\ng_0 = unit.standard_gravity","kernel":"python3","metadata":{"editable":false,"jupyter":{"source_hidden":true}},"no_halt":true,"pos":2,"start":1564141797546,"state":"done","type":"cell"}
{"cell_type":"code","end":1564141797813,"exec_count":2,"id":"fbcf50","input":"# ======= ========= ========= ========= ========= ========= ========= =========\n# USER: Enter case values using units listed above\n# force; Example: w = 1 * N / mm\nw = 10 * N / mm\n# distance from left end of beam to point of load; Example a = 1000 * mm\na = 1950 * mm\n# length of uniform load, b; Example b = 1000 * mm\nb = 100 * mm\n# span of beam; Example L = 3000 * mm\nL = 4000 * mm\nEI = 1 * N*mm**2 # default, otherwise enter E and I below\n# Young's Modulus for material; Example E = 200000 * MPa\nE = 200000 * MPa\n# Second Moment of Area for shape; Example I = 0.145*10**6 * mm**4\nI = 0.145*10**6 * mm**4 \nSAMPLE_SIZE = 99 # number of points within beam to compute, 99 is common\n# USER: Enter case values above. Altering anything below can be harmful.\n# ======= ========= ========= ========= ========= ========= ========= =========","kernel":"python3","no_halt":true,"pos":3,"start":1564141797768,"state":"done","type":"cell"}
{"cell_type":"code","end":1564141802555,"exec_count":4,"id":"f1291c","input":"# create beam array and load with position, shear, moment and deflection values\nbeam = np.zeros((4, SAMPLE_SIZE))\nPOSITION = 0 # array row for position along the beam\nSHEAR = 1 # array row for shear along the beam\nMOMENT = 2\nDEFLECTION = 3\nbeam[POSITION, : ] = np.linspace(0, L.magnitude, SAMPLE_SIZE) # position\nfor i in range(SAMPLE_SIZE):\n    beam[SHEAR, i] = shear_x(beam[POSITION, i]*L.units, w, a, b, L).magnitude # stuff shear values\n    beam[MOMENT, i] = moment_x(beam[POSITION, i]*L.units, w, a, b, L).magnitude # stuff moment values\n    beam[DEFLECTION, i] = P_beam[  : , i ].sum() # stuff deflection values","kernel":"python3","metadata":{"editable":false,"jupyter":{"source_hidden":true}},"no_halt":true,"pos":7,"start":1564141802459,"state":"done","type":"cell"}
{"cell_type":"code","end":1564141803251,"exec_count":5,"id":"a95fcc","input":"# plot shear diagram with matplotlib\nimport matplotlib.pyplot as plt\nplt.ion()\n# %matplotlib inline\nax = plt.plot(beam[POSITION, : ], beam[SHEAR, : ])\nplt.grid(b=True, which='both', axis='both')\nplt.xlabel(str('X [' + str(L.units) + ']'))\nplt.ylabel(str('V [' + str(V_1.units) + ']'))\nplt.title('Shear Diagram')\n# plt.legend()\n# cursor = Cursor(ax, useblit=True, color='red', linewidth=2)\nplt.show()\nprint('Left Reaction = V_1 = {}'.format(round(R_1, 3)))\nprint('Right Reaction = -V_2 = {}'.format(round(R_2, 3)))","kernel":"python3","metadata":{"editable":false,"jupyter":{"source_hidden":true}},"no_halt":true,"output":{"0":{"data":{"image/png":"2e116eff625c7aed884347c9a5ea2a7d22c657a7","text/plain":"<Figure size 432x288 with 1 Axes>"},"metadata":{"image/png":{"height":277,"width":399}}},"1":{"name":"stdout","text":"Left Reaction = V_1 = 500.0 N\nRight Reaction = -V_2 = 500.0 N\n"}},"pos":8,"scrolled":true,"start":1564141802609,"state":"done","type":"cell"}
{"cell_type":"code","end":1564141803953,"exec_count":6,"id":"7c582d","input":"# from matplotlib.widgets import Cursor\nbx = plt.plot(beam[POSITION, : ], beam[MOMENT, : ])\nplt.grid(b=True, which='both', axis='both')\nplt.xlabel(str('X [' + str(L.units) + ']'))\nplt.ylabel(str('M [' + str(V_1.units * L.units) + ']'))\nplt.title('Moment Diagram')\n# plt.legend()\n# cursor = Cursor(ax, useblit=True, color='red', linewidth=2)\nplt.show()\nprint('Maximum moment at {} is {}'.format(M_max_location, M_max_value))","kernel":"python3","metadata":{"editable":false,"jupyter":{"source_hidden":true}},"no_halt":true,"output":{"0":{"data":{"image/png":"dfdceb68a465e6a9c68b8e37a66067a7c802300d","text/plain":"<Figure size 432x288 with 1 Axes>"},"metadata":{"image/png":{"height":277,"width":416}}},"1":{"name":"stdout","text":"Maximum moment at 2000.0 mm is 987500.0 N * mm\n"}},"pos":9,"start":1564141803294,"state":"done","type":"cell"}
{"cell_type":"code","end":1564141804991,"exec_count":7,"id":"0eb0f8","input":"# plot deflection diagram\ncx = plt.plot(beam[POSITION, : ], beam[DEFLECTION, : ])\nplt.grid(b=True, which='both', axis='both')\nplt.xlabel(str('X [' + str(L.units) + ']'))\nplt.ylabel('$\\Delta$'+ ' [' + str(L.units) + ']')\nplt.title('Deflection Diagram')\n# plt.legend()\nplt.show()\n# print('Maximum deflection at {} is {}'.format(D_max_location, D_max_value))\nD_index = beam[DEFLECTION, : ].argmin()\nD_value = beam[DEFLECTION, D_index]\nD_location = beam[POSITION, D_index]\n\nprint('Location of maximum deflection: {} mm'.format(round(D_location, 4)))\nprint('Value of maximum deflection: {} mm'.format(round(D_value, 4)))\nprint('Agreement_Index:  {}'.format(Agreement_Index))\nprint('(1.0 is ideal, < 0.95 means sample size is too small and deflection values are spurious!)')","kernel":"python3","metadata":{"editable":false,"jupyter":{"source_hidden":true}},"no_halt":true,"output":{"0":{"data":{"image/png":"e47bb827adbbd031d5631be02a69e0ccf296885f","text/plain":"<Figure size 432x288 with 1 Axes>"},"metadata":{"image/png":{"height":277,"width":393}}},"1":{"name":"stdout","text":"Location of maximum deflection: 2000.0 mm\nValue of maximum deflection: -45.97 mm\nAgreement_Index:  1.0\n(1.0 is ideal, < 0.95 means sample size is too small and deflection values are spurious!)\n"}},"pos":10,"start":1564141803979,"state":"done","type":"cell"}
{"cell_type":"code","end":1564141805043,"exec_count":8,"id":"b3e28d","input":"D_index = beam[DEFLECTION, : ].argmin()\nD_value = beam[DEFLECTION, D_index]\nD_location = beam[POSITION, D_index]\nprint(D_index)\nprint(D_value)\nprint(D_location)","kernel":"python3","metadata":{"editable":false,"jupyter":{"source_hidden":true}},"no_halt":true,"output":{"0":{"name":"stdout","text":"49\n-45.96999860678092\n2000.0\n"}},"pos":16,"scrolled":true,"start":1564141805018,"state":"done","type":"cell"}
{"cell_type":"code","end":1564141805191,"exec_count":9,"id":"3d3061","input":"F_y = 350*MPa\nF_y.ito(kN/m**2)\nE.to(kN/m**2)","kernel":"python3","metadata":{"editable":false,"jupyter":{"source_hidden":true}},"no_halt":true,"output":{"0":{"data":{"text/html":"200000000.0 kilonewton/meter<sup>2</sup>","text/latex":"$200000000.0\\ \\frac{\\mathrm{kilonewton}}{\\mathrm{meter}^{2}}$","text/plain":"<Quantity(200000000.0, 'kilonewton / meter ** 2')>"},"exec_count":9}},"pos":17,"scrolled":true,"start":1564141805102,"state":"done","type":"cell"}
{"cell_type":"code","end":1564141805239,"exec_count":10,"id":"6fa0f7","input":"steel_density = 7850 * kg/m**3\nsteel_density_for_STAAD = steel_density * g_0\nsteel_density_for_STAAD.ito(kN/m**3)\nsteel_density_for_STAAD","kernel":"python3","metadata":{"editable":false,"jupyter":{"source_hidden":true}},"no_halt":true,"output":{"0":{"data":{"text/html":"76.9822025 kilonewton/meter<sup>3</sup>","text/latex":"$76.9822025\\ \\frac{\\mathrm{kilonewton}}{\\mathrm{meter}^{3}}$","text/plain":"<Quantity(76.9822025, 'kilonewton / meter ** 3')>"},"exec_count":10}},"pos":18,"scrolled":true,"start":1564141805206,"state":"done","type":"cell"}
{"cell_type":"code","end":1564141805317,"exec_count":11,"id":"82e8ba","input":"steel_shear_modulus = 77_000*MPa\nsteel_shear_modulus.to(kN/m**2)","kernel":"python3","metadata":{"editable":false,"jupyter":{"source_hidden":true}},"no_halt":true,"output":{"0":{"data":{"text/html":"77000000.0 kilonewton/meter<sup>2</sup>","text/latex":"$77000000.0\\ \\frac{\\mathrm{kilonewton}}{\\mathrm{meter}^{2}}$","text/plain":"<Quantity(77000000.0, 'kilonewton / meter ** 2')>"},"exec_count":11}},"pos":19,"scrolled":true,"start":1564141805295,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"3804e2","input":"End of Results\n\nTest and ancillary data is below in hidden cells.\n\nTo view test data:\n- Select cells below\n- Then click \"Edit\" on the menu\n- Then click \"Toggle Hide Input of Cells\"","metadata":{"editable":false},"pos":11,"type":"cell"}
{"cell_type":"markdown","id":"762fb1","input":"Beam Case: Simply Supported Beam - Uniform Load Partially Distributed\n\nWhen Given the following values:\n- span of beam, L in one of the listed length units\n- magnitude of load, w in one of the listed force units per unit of length\n- distance from left end of beam to start of load, a in one of the listed length units\n- length of uniform load, b in one of the listed length units\n- distance from left end of beam to point of interest, x in one of the listed length units\n- EI of member, use 1 * N * mm**2 if unknown; otherwise\n    - E is Young's Modulus in one of the listed pressure units\n    - I is Second Moment of Area in one of the listed length units to the 4th power\n- number of samples along beam, SAMPLE_SIZE in integer\n\nThis notebook will derive the following:\n- distance from right end of load to right end of beam, c\n- reactions at ends of beams, R_1 and R_2\n- plot graphs of shear, moment and deflection\n- and list maximum values for each\n\nAcceptable units:\n- Length: m, mm, inch, foot\n- Force: N, kN, lbf, kip\n- Pressure: kPa, MPa, psi, ksi","metadata":{"editable":true,"jupyter":{}},"pos":1,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"7980ea","input":"Figure 2 from DA6 by American Wood Council, 2007\n\nRevision History:\n- 1.0 26-Jul-2019 E.Durham added deflection calculation using equivalent point loads\n- 0.0 25-Jul-2019 E.Durham created initial notebook from Beam_1.1.ipynb.\n\nTODO:\n- Add test data and expected results","metadata":{"editable":true,"jupyter":{}},"pos":0,"state":"done","type":"cell"}
{"cell_type":"raw","id":"499f23","input":"# Notebook test results\nMaximum moment at 1000 mm is 750000.0 N * mm\nbeam[DEFLECTION, : ].min() = D_max = -32.126661002047484 mm\nbeam[SHEAR, : ].max() = V_max_pos = 750.0 newton\nbeam[SHEAR, : ].min() = V_max_neg = -250.0 newton","metadata":{"editable":false,"jupyter":{"source_hidden":true}},"pos":15,"type":"cell"}
{"cell_type":"raw","id":"5ed75f","input":"# Begin of Test and ancillary data\n# Test Data\nP = 1000 * N\na = 1000 * mm\nL = 4000 * mm\nE = 200000 * MPa\nI = 0.145*10**6 * mm**4","metadata":{"editable":false,"jupyter":{"outputs_hidden":false,"source_hidden":true}},"pos":12,"type":"cell"}
{"cell_type":"raw","id":"92dec2","input":"# STAAD Results\nV_max_pos = 0.75 kN at 0.00 mm\nV_max_neg = -0.25 kN at 4000.00 mm\nM_max = -0.75 kN-m at 1000 mm\nD_max = -32.127 mm at 1763 mm","metadata":{"editable":false,"jupyter":{"source_hidden":true}},"pos":14,"type":"cell"}
{"cell_type":"raw","id":"e0b6fe","input":"# STAAD Model\nSTAAD SPACE\nSTART JOB INFORMATION\nENGINEER DATE 24-Jul-19\nEND JOB INFORMATION\nINPUT WIDTH 79\nUNIT METER KN\nJOINT COORDINATES\n1 0 0 0; 2 0 0 4;\nMEMBER INCIDENCES\n1 1 2;\nDEFINE MATERIAL START\nISOTROPIC STEEL\nE 2.05e+008\nPOISSON 0.3\nDENSITY 76.8195\nALPHA 1.2e-005\nDAMP 0.03\nTYPE STEEL\nSTRENGTH FY 253200 FU 407800 RY 1.5 RT 1.2\nISOTROPIC 350W\nE 2e+008\nPOISSON 0.3\nDENSITY 76.9822\nALPHA 1.17e-005\nG 7.7e+007\nTYPE STEEL\nSTRENGTH FY 350000 FU 450000 RY 1 RT 1\nEND DEFINE MATERIAL\nMEMBER PROPERTY CANADIAN\n1 TABLE ST HSSP48x4.8HA\nCONSTANTS\nMATERIAL 350W ALL\nSUPPORTS\n1 2 PINNED\nMEMBER RELEASE\n1 START MP 0.999\nLOAD 1 LOADTYPE None  TITLE LOAD CASE 1\nMEMBER LOAD\n1 CON GY -1 1\nPERFORM ANALYSIS\nFINISH","metadata":{"editable":false,"jupyter":{"source_hidden":true}},"pos":13,"type":"cell"}
{"end":1564141802411,"exec_count":3,"id":"bd907f","input":"DEBUG = False\n# convert units of user variables to newton for force and millimetres for distance\ntry :\n    w.ito(N/mm)\n    a.ito(mm)\n    b.ito(mm)\n    L.ito(mm)\n    SAMPLE_SIZE = int(SAMPLE_SIZE)\n    EI = (E*I).to(N*mm**2)\nexcept:\n    print('ERROR: The user entered values cannot be converted to expected units. Results below are highly suspect.')\n    print('Please, re-enter user values using accepted units and re-run notebook')\n# Derive distance c\nc = L - (a + b)\n# Calculate Reactions\n# reaction at left support\nR_1 = ((w*b)/(2*L))*(2*c + b) # max when a < c\n# reaction at right support\nR_2 = ((w*b)/(2*L))*(2*a + b) # max when a < c\n# Derive Shear V_1 and V_2\nV_1 = R_1\nV_2 = R_2\n# Derive max moment\nM_max_value = str(round((R_1*(a+(R_1/(2*w)))),3))\nM_max_location = a + (R_1/w)\n# TODO: Derive max deflection\n# D_max_value = \n# D_max_value = str(round(D_max_value, 3))\n# D_max_location = \n# D_max_location = \n\ndef shear_x(x, w, a, b, L):\n    \"\"\"\n    Determine shear for simple beam w/ partial uniformly distributed load at any position x.\n    \n    where\n    x = distance from left end of beam to point of interest\n    w = uniform load\n    a = distance from left end of beam to start of load\n    b = length of uniform load\n    L = length of span of beam\n\n    The function does not allign units. Units of x, a, b and L must be identical. \n\n    Returns value of shear at x in units_of_w * units_of_L\n    \n    \"\"\"\n    c = L - (a + b) # derive c given a, b and L\n    R_1 = ((w*b)/(2*L))*(2*c + b)\n    R_2 = ((w*b)/(2*L))*(2*a + b)\n    if x >= 0*x.units and x <= a:\n        V_x = R_1\n    elif x >= (a+b) and x <= L:\n        V_x = -R_2\n    elif x > a and x < (a+b):\n        V_x = R_1 - w*(x-a)\n    else:\n        V_x = float('NaN')\n        print(\"Error: x cannot be less than 0 or greater than L which is {} in this case\".format(L))\n    return V_x\n\ndef moment_x(x, w, a, b, L):\n    \"\"\"\n    Determine moment for simple beam w/ concentrated load at any position x.\n\n    where\n    x = distance from left end of beam to point of interest\n    w = uniform load\n    a = distance from left end of beam to point of load\n    b = length of uniform load\n    L = length of span of beam\n\n    The function does not allign units. Units of x, a, b and L must be identical. \n\n    Returns value of moment at x in units_of_P * units_of_x\n    \"\"\"\n    c = L - (a + b) # derive c given a, b and L\n    R_1 = ((w*b)/(2*L))*(2*c + b)\n    R_2 = ((w*b)/(2*L))*(2*a + b)\n    if x >= 0*x.units and x < a:\n        M_x = R_1*x\n    elif x >= a and x <= (a+b):\n        M_x = R_1*x - ((w/2)*(x-a)**2)\n    elif x > (a+b):\n        M_x = R_2*(L-x)\n    else:\n        M_x = float('NaN')\n        print(\"Error: x cannot be less than 0 or greater than L which is {} in this case\".format(L))\n    return M_x\n\ndef deflection_x(x, w, a, b, L, EI=1):\n    \"\"\"\n    Determine deflection for simple beam w/ partial uniform load at any position x.\n\n    where\n    x = distance from left end of beam to point of interest\n    w = uniform load\n    a = distance from left end of beam to start of load\n    b = length of uniform load\n    L = length of span of beam\n    EI = modulus of elasticity of material in units_of_P / units_of_L**2 times\n    second moment of area in units_of_L**4. Thus, EI is in units_of_P * units_of_L**2.\n    Default value for EI is 1 in which case values returned are overstated by actual value\n    of EI. That is, to determine deflection for a given EI, divide deflection here by\n    actual value of EI.\n\n    The function does not allign units. Units of x, a, b and L must be identical. \n\n    Returns value of deflection at x in units_of_L\n    \"\"\"\n    c = L - (a + b) # derive c given a, b and L\n    R_1 = ((w*b)/(2*L))*(2*c + b)\n    R_2 = ((w*b)/(2*L))*(2*a + b)\n    deflection_x = 0 * L.units\n    return deflection_x\ndef deflection_1_x(x, P, a, L, EI=1):\n    \"\"\"\n    Determine deflection for simple beam w/ concentrated load at any position x.\n\n    where\n    x = distance from left end of beam to point of interest\n    P = concentrated load\n    a = distance from left end of beam to point of load\n    L = length of span of beam\n    EI = modulus of elasticity of material in units_of_P / units_of_L**2 times\n    second moment of area in units_of_L**4. Thus, EI is in units_of_P * units_of_L**2.\n    Default value for EI is 1 in which case values returned are overstated by actual value\n    of EI. That is, to determine deflection for a given EI, divide deflection here by\n    actual value of EI.\n\n    The function does not allign units. Units of x, a and L must be identical. \n\n    Returns value of deflection at x in units_of_L\n    \"\"\"\n    b = L - a # derive b given a and L\n    if x == a:\n        deflection_x = -(P*a**2*b**2)/(3*EI*L)\n    elif x >= 0*x.units and x < a:\n        deflection_x = -((P*b*x)/(6*EI*L))*(L**2-b**2-x**2)\n    elif x > a and x <= L:\n        deflection_x = -((P*a*(L-x))/(6*EI*L))*(2*L*x-x**2-a**2)\n    else:\n        deflection_x = float('NaN')\n        print(\"Error: x cannot be less than 0 or greater than L which is {} in this case\".format(L))\n    return deflection_x\n# convert partially distributed uniform load into equivalent point loads\nP_quantity = int((b/L)*SAMPLE_SIZE)\nNormal_Tributary_width = L/SAMPLE_SIZE\nP = (w*b)/P_quantity\n\nP_beam_position = np.linspace(0, L.magnitude, SAMPLE_SIZE)\n# array of point loads\nP_array = np.zeros(SAMPLE_SIZE)\nfor i in range(SAMPLE_SIZE):\n    if i*Normal_Tributary_width < a:\n        P_array[i] = 0\n    elif i*Normal_Tributary_width >= a and i*Normal_Tributary_width <= (a+b):\n        P_array[i] = P.magnitude\n    else:\n        P_array[i] = 0\n\n# array of deflections\nrows = SAMPLE_SIZE\ncols = SAMPLE_SIZE\nP_beam = np.zeros((rows, cols))\n\n\nfor i in range(rows):\n    for j in range(cols):\n        local_x = P_beam_position[j]*L.units\n        local_P = P_array[i]*(w.units/L.units)\n        local_a = (i*Normal_Tributary_width) # ???!!!???\n        local_L = L\n        local_EI = EI\n        P_beam[i, j] = deflection_1_x(local_x, local_P, local_a, local_L, local_EI).magnitude\n\nAgreement_Index = 1/(P_array.sum()/(w*b).magnitude)\nif DEBUG == True:\n    print('w = {}'.format(w))\n    print('L = {}'.format(L))\n    print('a = {}'.format(a))\n    print('b = {}'.format(b))\n    print('c = {}'.format(c))\n    print('P_quantity: {}'.format(P_quantity))\n    print('Normal_Tributary_width: {}'.format(Normal_Tributary_width))\n    print('Agreement_Index (1.0 is ideal): {}'.format(Agreement_Index.magnitude))\n    print('P is {}'.format(P))\n    print('P_array is')\n    print(P_array)\n    print('P_beam is')\n    print(P_beam)","kernel":"python3","metadata":{"editable":false,"jupyter":{"source_hidden":true}},"no_halt":true,"pos":4,"start":1564141797910,"state":"done","type":"cell"}
{"id":0,"time":1564127895687,"type":"user"}
{"last_load":1564065502496,"type":"file"}